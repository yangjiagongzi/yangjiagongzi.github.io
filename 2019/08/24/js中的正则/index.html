<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!--Description-->
  
  <meta
    name="description"
    content="正则表达式正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。
创建方式
使用 RegExp 对象创建第一个参数就是我们的模式字符串,第二个参数可选，模式修饰符，”i”表示忽略大小写，”g”表示全局匹配

1const re"
  />
  

  <!--Author-->
  
  <meta name="author" content="Near" />
  

  <!--Open Graph Title-->
  
  <meta property="og:title" content="js中的正则" />
  

  <!--Open Graph Description-->
  

  <!--Open Graph Site Name-->
  <meta property="og:site_name" content="杨家公子的博客" />

  <!--Type page-->
  
  <meta property="og:type" content="article" />
  

  <!--Page Cover-->
   
  <meta name="twitter:card" content="summary" />
    

  <!-- Title -->
  
  <title>js中的正则 - 杨家公子的博客</title>

  <!-- Bootstrap Core CSS -->
  <link
    rel="stylesheet"
    href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css"
    integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd"
    crossorigin="anonymous"
  />

  <!-- Custom Fonts -->
  <link
    href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css"
    rel="stylesheet"
    type="text/css"
  />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->

  <!-- Gallery -->
  <link
    href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css"
    type="text/css"
    rel="stylesheet"
  />

  <!-- Custom CSS -->
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2019/08/24/js%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/">
                js中的正则
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-08-24</span>
            
            
            
                <span class="category">
                    <a href="/categories/javascript/">javascript</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。</p>
<h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a><font color=#87CEFA>创建方式</font></h4><ul>
<li>使用 RegExp 对象创建<br>第一个参数就是我们的模式字符串,第二个参数可选，模式修饰符，”i”表示忽略大小写，”g”表示全局匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const reg &#x3D; new RegExp(&#39;study&#39;, &#39;ig&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>直接声明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const reg &#x3D; &#x2F;study&#x2F;ig</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式的方法"><a href="#正则表达式的方法" class="headerlink" title="正则表达式的方法"></a>正则表达式的方法</h3><h4 id="RegExp-test"><a href="#RegExp-test" class="headerlink" title="RegExp.test"></a><font color=#87CEFA>RegExp.test</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则表达式对象名.test(“字符串”)</span><br></pre></td></tr></table></figure>

<p>用于检测提供的目标字符串是否包含正则表达式的匹配内容，如果包含返回 true,否则返回 false</p>
<h4 id="RegExp-exec"><a href="#RegExp-exec" class="headerlink" title="RegExp.exec"></a><font color=#87CEFA>RegExp.exec</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则表达式对象名.exec(“字符串”)</span><br></pre></td></tr></table></figure>

<p>用于在字符串中查找指定正则表达式，如果 exec()方法执行成功，则返回包含该查找字符串的相关信息数组。如果执行失败，则返回 null。</p>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><ul>
<li><p>{} 表示括号前面的一个字符连续出现的次数</p>
<blockquote>
<p>{m}：表示括号前面的一个字符只能连续出现 m 次</p>
</blockquote>
<blockquote>
<p>{m,}:表示至少出现 m 次，即 m~无限次</p>
</blockquote>
<blockquote>
<p>{m,n}:表示至少出现 m 次，最多出现 n 次，即 m~n 次</p>
</blockquote>
</li>
<li><p>[] 表示范围</p>
<blockquote>
<p>[\u4e00-\u9fa5]:表示中文的范围</p>
</blockquote>
<blockquote>
<p>[^\u4e00-\u9fa5]:表示非中文</p>
</blockquote>
<blockquote>
<p>[^a-za-z]:表示非字母</p>
</blockquote>
<blockquote>
<p>[^0-9]:表示非数字</p>
</blockquote>
<blockquote>
<p>[^ ]:表示非空格</p>
</blockquote>
</li>
<li><p>() 表示组</p>
</li>
<li><p>* 等同于{0,}表示 0~无限次</p>
</li>
<li><p>+ 等同于{1,} 表示 1~无限次，至少出现 1 次</p>
</li>
<li><p>? 等同于{0,1}表示 0~1 次，最多可出现 1 次，可以不出现</p>
</li>
<li><p>^ 定（断）头:表示必须以^后面的一个字符开头</p>
</li>
<li><p>$ 定（断）尾:表示必须以$前面的一个字符结尾</p>
</li>
<li><p>. 表示模糊匹配，一个点可以匹配一个任意字符</p>
</li>
<li><p>| 表示或者</p>
</li>
<li><p>\ 表示转义字符</p>
<blockquote>
<p>\d:表示数字 [0-9]</p>
</blockquote>
<blockquote>
<p>\D:表示非数字[^0-9]</p>
</blockquote>
<blockquote>
<p>\w:表示字母、数字、下划线 [a-zA-Z0-9_]</p>
</blockquote>
<blockquote>
<p>\W:表示非字母、数字、下划线 [^a-za-z0-9_]</p>
</blockquote>
<blockquote>
<p>\s:表示空白符</p>
</blockquote>
<blockquote>
<p>\S:表示非空白符</p>
</blockquote>
<blockquote>
<p>\b:匹配单词边界</p>
</blockquote>
</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><h4 id="从上往下优先级由高到低"><a href="#从上往下优先级由高到低" class="headerlink" title="从上往下优先级由高到低"></a><font color=#87CEFA>从上往下优先级由高到低</font></h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">\</td>
<td align="left">转义</td>
</tr>
<tr>
<td align="center">( ) [ ]</td>
<td align="left">圆括号和方括号</td>
</tr>
<tr>
<td align="center">* + ? {n} {n,} {n,m}</td>
<td align="left">限定符</td>
</tr>
<tr>
<td align="center">^ $ \任何元字符</td>
<td align="left">顺序和位置</td>
</tr>
<tr>
<td align="center">|</td>
<td align="left">或</td>
</tr>
</tbody></table>
<h3 id="捕获和非捕获"><a href="#捕获和非捕获" class="headerlink" title="捕获和非捕获"></a>捕获和非捕获</h3><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p>
<blockquote>
<p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。<br>什么意思呢？看个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;123abc&#39;.replace(&#x2F;(\d+)\D+&#x2F;g,&#96;[$&#123;&#39;$1&#39;&#125;]&#96;)</span><br></pre></td></tr></table></figure>

<p>这个例子意思就是在字符串“123abc”中用另一个字符串替换掉正则匹配到的内容，用来替换的字符串是个字符串模版，里面有个变量是”$1”，代表正则中第一个捕获组的内容也就是正则中<code>(\d+)</code>匹配到的内容，这就是捕获组。</p>
<h4 id="数字编号捕获组"><a href="#数字编号捕获组" class="headerlink" title="数字编号捕获组"></a><font color=#87CEFA>数字编号捕获组</font></h4><p>上面简单的例子可以看到<code>(\d+)</code>捕获到的组自动命名了序号 1，<br>那我们接着来实验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regResult &#x3D; &#x2F;(0\d&#123;2&#125;)-(\d&#123;8&#125;)&#x2F;g.exec(&#39;010-12345678&#39;);</span><br><span class="line">console.log(regResult);</span><br></pre></td></tr></table></figure>

<p>我们可以看到输出中捕获组长度为 3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: &quot;010-12345678&quot;</span><br><span class="line">1: &quot;010&quot;</span><br><span class="line">2: &quot;12345678&quot;</span><br><span class="line">groups: undefined</span><br><span class="line">index: 0</span><br><span class="line">input: &quot;010-12345678&quot;</span><br><span class="line">length: 3</span><br></pre></td></tr></table></figure>

<p>第 0 组为整个表达式，第一组为第一个小括号匹配到的内容，即<code>(0\d{2})</code>，第二组为第二个小括号匹配到的内容，即<code>(\d{8})</code>，那如果有多个括号嵌套呢？我们试一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regResult &#x3D; &#x2F;(0(\d&#123;2&#125;))-(\d&#123;8&#125;)&#x2F;g.exec(&#39;010-12345678&#39;);</span><br><span class="line">console.log(regResult);</span><br></pre></td></tr></table></figure>

<p>看到输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: &quot;010-12345678&quot;</span><br><span class="line">1: &quot;010&quot;</span><br><span class="line">2: &quot;10&quot;</span><br><span class="line">3: &quot;12345678&quot;</span><br><span class="line">groups: undefined</span><br><span class="line">index: 0</span><br><span class="line">input: &quot;010-12345678&quot;</span><br><span class="line">length: 4</span><br></pre></td></tr></table></figure>

<p>可以看出分组是按照小括号从左往右出现的顺序来进行编号的</p>
<h4 id="命名编号捕获组"><a href="#命名编号捕获组" class="headerlink" title="命名编号捕获组"></a><font color=#87CEFA>命名编号捕获组</font></h4><p>和数字编号捕获组类似，只不过给捕获组增加了名字，从 ECMAScript 2018 开始才有的这个特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regResult &#x3D; &#x2F;(?&lt;area&gt;0\d&#123;2&#125;)-(\d&#123;8&#125;)&#x2F;g.exec(&#39;010-12345678&#39;);</span><br><span class="line">console.log(regResult);</span><br></pre></td></tr></table></figure>

<p>在正则分组的小括号开头增加<code>?&lt;name&gt;</code>就给这个分组起了名字<br>上面例子中给第一个分组起了名字叫<code>area</code>,打印结果可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: &quot;010-12345678&quot;</span><br><span class="line">1: &quot;010&quot;</span><br><span class="line">2: &quot;12345678&quot;</span><br><span class="line">groups: &#123;</span><br><span class="line">  area: &quot;010&quot;</span><br><span class="line">&#125;</span><br><span class="line">index: 0</span><br><span class="line">input: &quot;010-12345678&quot;</span><br><span class="line">length: 3</span><br></pre></td></tr></table></figure>

<p>字段 groups 里多了 area 的字段，也可以直接在正则外使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;010-12345678&#39;.replace(&#x2F;(?&lt;area&gt;0\d&#123;2&#125;)-(\d&#123;8&#125;)&#x2F;g, &#39;$&lt;area&gt;&#39;)</span><br></pre></td></tr></table></figure>

<p>把整个字符串中被正则匹配到的地方替换成命名为<code>area</code>的分组</p>
<h4 id="非捕获"><a href="#非捕获" class="headerlink" title="非捕获"></a><font color=#87CEFA>非捕获</font></h4><p>非捕获的意思就是不进行捕获，在捕获组的小括号开头增加<code>?:</code>，例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const regResult &#x3D; &#x2F;(?:0\d&#123;2&#125;)-(\d&#123;8&#125;)&#x2F;g.exec(&#39;010-12345678&#39;);</span><br><span class="line">console.log(regResult);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: &quot;010-12345678&quot;</span><br><span class="line">1: &quot;12345678&quot;</span><br><span class="line">groups: undefined</span><br><span class="line">index: 0</span><br><span class="line">input: &quot;010-12345678&quot;</span><br><span class="line">length: 2</span><br></pre></td></tr></table></figure>

<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>通过上面的例子我们已经明白了如何在正则外面使用捕获组，使用<code>$1</code>或<code>$&lt;name&gt;</code>来使用。那么反向引用就是在正则内部进行引用。</p>
<h4 id="数字编号组反向引用"><a href="#数字编号组反向引用" class="headerlink" title="数字编号组反向引用"></a><font color=#87CEFA>数字编号组反向引用</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;(\d+)\D+\1&#x2F;g.test(&#39;123abc123&#39;));</span><br></pre></td></tr></table></figure>

<p>首先我们看到正则的意思是<code>(1到无穷个数字)1到无穷个非数字\1</code>,这里的<code>\1</code>代表的就是我第一个捕获组捕获到了什么内容那我这里就是什么内容，这就是反向引用。注意：这里是内容，意思就是匹配的结果，而不是拿引用的组的表达式再匹配一次。再一个例子：简单判断成语是不是’ABAC’形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const reg &#x3D; &#x2F;([\u4e00-\u9fa5])[\u4e00-\u9fa5]\1[\u4e00-\u9fa5]&#x2F;g;</span><br><span class="line">console.log(&#39;人山人海&#39;, reg.test(&#39;人山人海&#39;));</span><br><span class="line">console.log(&#39;海底捞针&#39;, reg.test(&#39;海底捞针&#39;));</span><br></pre></td></tr></table></figure>

<p>第一个捕获组用<code>\1</code>表示，那第二个捕获组就用<code>\2</code>表示，以此类推</p>
<h4 id="命名编号组反向引用"><a href="#命名编号组反向引用" class="headerlink" title="命名编号组反向引用"></a><font color=#87CEFA>命名编号组反向引用</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;(?&lt;firstword&gt;[\u4e00-\u9fa5])[\u4e00-\u9fa5]\k&lt;firstword&gt;[\u4e00-\u9fa5]&#x2F;g.test(&#39;人山人海&#39;)</span><br></pre></td></tr></table></figure>

<p>用<code>\k&lt;name&gt;</code>来引用命名的捕获组，同样的，从 ECMAScript 2018 开始才有的这个特性。</p>
<h3 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h3><h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a><font color=#87CEFA>贪婪模式</font></h4><p>字面意思就是想要更多。当正则表达式中包含能接受重复的限定符时<code>(例如：\*、+、？、{n,m})</code>，在使整个表达式能得到匹配的前提下，匹配尽可能多的字符。注意这里是有前提的，<code>在使整个表达式能得到匹配的前提下</code>，默认是贪婪模式。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;).*$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>整个表达式能够得到匹配后，<code>{1,6}</code>会尽可能多的匹配字符，输出可以看到匹配了”123456”<br>再看另一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;)\d&#123;8&#125;$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>这个正则为了使整个表达式能够得到匹配，首先得满足<code>\d{8}</code>，因此虽然<code>\d{1,6}</code>想获得足够多的字符，但是必须先让整体得到匹配，它虽然贪婪，但是还是得把集体的利益放在首位，这就是贪婪模式。</p>
<h4 id="非贪婪模式（懒惰模式）"><a href="#非贪婪模式（懒惰模式）" class="headerlink" title="非贪婪模式（懒惰模式）"></a><font color=#87CEFA>非贪婪模式（懒惰模式）</font></h4><p>当正则表达式中包含能接受重复的限定符时<code>(例如：\*、+、？、{n,m})</code>，在使整个表达式能得到匹配的前提下，匹配尽可能少的字符。注意这里也是有前提的，<code>在使整个表达式能得到匹配的前提下</code>。大家应该能够明白是什么意思了，我们看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;?).*$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>整个表达式能够得到匹配后，<code>{1,6}</code>会尽可能少的匹配字符，是因为这个<code>?</code>，在重复限定符<code>(例如：\*、+、？、{n,m})</code>后面紧跟<code>?</code>代表这个重复限定符为非贪婪模式，输出可以看到匹配了”1”，同样的它会以大局为重，优先使整个表达式能够得到匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;?)\d&#123;3&#125;$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>虽然它不想要很多字符，但是为了大局，它也要了‘123456’</p>
<h4 id="多个的优先级"><a href="#多个的优先级" class="headerlink" title="多个的优先级"></a><font color=#87CEFA>多个的优先级</font></h4><p>如果有多个贪婪在一起呢？会出现什么情况？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;)(\d&#123;1,6&#125;)$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>从结果我们可以看到第一个组捕获到了<code>123456</code>，第二个组捕获到了<code>789</code>。</p>
<p>多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p>
<p>第一组想要最多，看整体满足的前提下后发现它可以拿最多的 6 个，它就拿了 6 个，第二组想要更多，但是第一组只给他留了 3 个，它就只能拿三个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;^(\d&#123;1,6&#125;?)(\d&#123;1,6&#125;?)$&#x2F;.exec(&#39;123456789&#39;));</span><br></pre></td></tr></table></figure>

<p>非贪婪也类似，从左往右优先满足，第一组想要最少的，但是发现只要一个的话满足不了整体匹配的前提，发现最少得拿 3 个才能满足，所以它拿了 3 个，第二组也不想要这么多，但是第一组给它留了 6 个，那它只能要 6 个</p>
<p>所以虽然他们贪婪或是懒惰，但是他们都以整体利益出发，而且懂礼貌，让先来的先挑。</p>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><blockquote>
<p>断言：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出 aa2 前面有 bb3，也可以找出 aa2 后面有 ss1.</p>
</blockquote>
<blockquote>
<p>零宽：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p>
</blockquote>
<ul>
<li><p>前瞻断言</p>
<ul>
<li><code>(?=exp)</code> 顺序肯定环视，表示所在位置右侧能够匹配 exp</li>
<li><code>(?!exp)</code> 顺序否定环视，表示所在位置右侧不能匹配 exp</li>
</ul>
</li>
<li><p>后瞻断言</p>
<ul>
<li><code>(?&lt;=exp)</code> 逆序肯定环视，表示所在位置左侧能够匹配 exp</li>
<li><code>(?&lt;!exp)</code> 逆序否定环视，表示所在位置左侧不能匹配 exp</li>
</ul>
</li>
</ul>
<h4 id="顺序肯定环视-正前瞻"><a href="#顺序肯定环视-正前瞻" class="headerlink" title="顺序肯定环视(正前瞻)"></a><font color=#87CEFA>顺序肯定环视(正前瞻)</font></h4><p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;\w*(?&#x3D;\.gif)&#x2F;.exec(&#39;hello.gif&#39;));</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0: &quot;hello&quot;</span><br><span class="line">groups: undefined</span><br><span class="line">index: 0</span><br><span class="line">input: &quot;hello.gif&quot;</span><br><span class="line">length: 1</span><br></pre></td></tr></table></figure>

<p>这个前瞻断言的正则意思就是在某一个位置上，它的左边是<code>\w*</code>，它的右边是<code>.gif</code>，并且这个正则匹配的宽度是<code>\w*</code>的宽度，因为是零宽断言，所以不返回断言之中的内容。<br>比如这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;hello(?&#x3D;\.gif)\.gif&#x2F;.test(&#39;hello.gif&#39;));</span><br></pre></td></tr></table></figure>

<p>这个例子虽然比较鸡肋，但是可以很好的理解零宽断言，正则其实是<code>/hello\.gif/</code>，但是在<code>hello</code>和<code>.</code>中间的位置加了一个断言，断定在我这个位置之后是 gif。我只贡献了一个位置，没有其他的贡献。</p>
<p>上面我们讲的就是前瞻断言中的顺序肯定环视，那么顺序否定环视就很好理解了，就是这个位置之后不是什么什么。</p>
<h4 id="顺序否定环视-负前瞻"><a href="#顺序否定环视-负前瞻" class="headerlink" title="顺序否定环视(负前瞻)"></a><font color=#87CEFA>顺序否定环视(负前瞻)</font></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;\w*(?!\.gif)&#x2F;.exec(&#39;hello.gif&#39;));</span><br></pre></td></tr></table></figure>

<p>我们可以看到匹配的是<code>hell</code>，因为他要找到一个位置，这个位置之前是<code>\w*</code>，之后不是<code>.gif</code>，并且<code>\w*</code>还是贪婪模式，那么只好找到<code>l</code>和<code>o</code>中间的位置，这样这个位置前面满足<code>\w*</code>，后面是<code>o.gif</code>也满足不是<code>.gif</code>这个条件，而且贪婪的那组已经最多了，再多位置就不满足正则了。</p>
<h4 id="逆序肯定环视-正后瞻"><a href="#逆序肯定环视-正后瞻" class="headerlink" title="逆序肯定环视(正后瞻)"></a><font color=#87CEFA>逆序肯定环视(正后瞻)</font></h4><p>既然有我断定我在的位置右边有什么什么，那应该也有我断定我在的位置左边有什么什么。值得注意的是，从 ECMAScript 2018 开始才有的这个特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#x2F;(?&lt;&#x3D;function\s).*&#x2F;.exec(&#39;function test&#39;));</span><br></pre></td></tr></table></figure>

<p>找到一个位置，这个位置前面是<code>&#39;function\s&#39;</code>，后面是<code>&#39;.*&#39;</code>，并且这个位置没有贡献任何字符串</p>
<h4 id="逆序否定环视-负后瞻"><a href="#逆序否定环视-负后瞻" class="headerlink" title="逆序否定环视(负后瞻)"></a><font color=#87CEFA>逆序否定环视(负后瞻)</font></h4><p>相似的，这个意思就是我在的这个位置左边不能有什么什么，相同的，也是从 ECMAScript 2018 开始才有的这个特性。</p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/随记/">#随记</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
        <div class="footer-copyright">愿你一生努力，一生被爱，想要的都拥有，得不到的都释怀。</div>
      </div>
    </div>
  </div>
</footer>


<!-- After footer scripts -->

<script src="/js/jquery.js"></script>
 
<script src="/js/tweenmax.js"></script>
 
<script src="/js/main.js"></script>



</body>

</html>